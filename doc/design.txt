= The Design and Implementation of a Mobile OPAC Client for the Evergreen System
Steven Chan
v1.0, 2010-09-15:

A report prepared for the
http://sitka.bclibraries.ca/[Sitka project]
and the http://kcls.org/[King County Library System].

== Introduction

In the Summer of 2010,
it was decided to implement a replacement for the Evergreen `slimpac',
one that would be useful for users of mobile devices or dialup access.
The first audience group is relevant for the King County Library System,
whose patrons had been using a rudimentary `airpac'
that came as part of their legacy proprietary system.
The second audience group is relevant for the Thompson-Nicola Regional District,
a member of the Sitka consortium that has online users
wanting to access its OPAC with dialup modems.

The following document discusses the high-level design goals for the project,
and how those goals could be met.
Also discussed is an overview of the software architecture,
and some aspects of the development environment.
The document is useful for future designers
wishing to change or expand the software.

== Design Goals and Solutions
Our design goals can be summarized in four rules.
Two rules define the target audiences;
two other rules define the software features
and the intent of the architectural framework.

=== Target mobile devices and small screens.
Mobile devices present an extreme version of the cross-browser problem,
whereby the same software has to work across many web browsers
with variations in rendering engines and Javascript engines.
Moreover, mobile devices have small screens
and rely on touch screens or keyboards for navigation.

* _Use the http://jquery.com[jQuery] Javascript library_
for its aggressive testing against mobile web browsers.
In late Summer 2010, they announced a special project
to upgrade the library to handle a diverse set of mobile web browsers;
see http://jquerymobile.com for more details.
The new version is scheduled to become available in late 2010.

* _Show only what the user is focussed on_
by using accordion-style folding and unfolding.
The main page is designed to show links to all functional areas.
An area will unfold if the user clicks its link,
while the other areas will fold up to yield its portion of the screen.

* _Use keyboard shortcuts and hover points._
For example, if the user presses the enter, escape, or tab key
a reasonable, expected action will occur in the context of each functional area.
If the user hovers over a data area, collateral information (if any) will pop up.

=== Target narrow bandwidth.
Dialup users with a desktop workstation will be accessing the mobile opac
through the narrow bandwidth of a 56 Kilobit per second modem.
Meanwhile, mobile users will be accessing through wireless networks
that could offer no more than modem bandwidth at times.

* _Minimize the amount of files to download._
For example, we have one CSS file and one HTML file.
The single HTML file includes a minimal body that is dynamically filled by executing Javascript.
There are numerous Javascript files to download,
but whenever possible, they are `bunched' into single files.

* _Minimize the size of Javascript files to download_
by stripping out comments and white spaces, for example.
We use http://code.google.com/closure/compiler/[Google's Closure compiler]
to do the chore for us.
The Closure compiler offers a more advanced level of minimization,
but even using the basic level, we are able to generally halve the size of files.

* _Download Javascript files on demand._
It is not necessary to download all Javascript files at once.
For example, the initial download is a collection of common utilities
that are needed by most functional areas.
If the user presses the search link,
then the search bar and search result plugins are downloaded;
if the user presses the login link,
then the login window plugin is downloaded;
and so on.

* _Reduce unnecessary downloads_
by cacheing responses from the server within the browser.
The responses from the Evergreen server for some AJAX calls
contain data objects that never or rarely change,
for example, search results or the organizational tree.
We arrange for the software to recognize those calls and cache them in memory for a while.
If the user revisits functional areas involving data objects which are cached,
they are accessed from memory rather than from the network.

=== Implement a reduced set of OPAC features.
For an initial effort,
the mobile opac offers a priority set of features rather than the full set.
We list the full set of features,
answering 'Yes', 'No', or 'Partial'
as to whether they are part of the mobile set.

. Do basic searches of public catalogue? 'Yes'
. Do advanced searches? 'No'
. Do numeric searches? 'No'
. View a list of search results? 'Partial'.
Cannot view cover art and other collateral data.
. View related subjects, authors, or series? 'No'
. Browse by call numbers (`shelfbrowser')? 'No'
. View title and copy details? 'Partial'.
Cannot view synopsis and other collateral data.
Cannot view MARC record.
. Create holds? 'Partial'.
Title-level holds only.
. Log in or log out? 'Yes'
. View or edit patron profile? 'No'
. View or edit patron settings, and having them stored as cookies? 'No'
. View fines? 'Yes'
. View, renew, or cancel checkouts? 'Yes'
. View or edit holds? 'Partial'.
Cannot suspend by specific date.
. View or edit bookbags? 'No'

=== Use a software framework that would allow future designers to easily make changes and extensions.
We want to allow future designers
(as well as the original designers coming back to do further work)
to easily make changes and extensions, without a lot of time and effort.
This can only be done if the software architecture is designed with the intention in mind.

* _Split software into two layers_,
the UI layer for interacting with the user
and the EG layer for communicating with Evergreen services.
We choose an obvious pattern of design to isolate changes in the user interface
and from changes to Evergreen services.
Our goal is to draw the line between the two parts as naturally as possible.
+
UI would deal with the interactive behaviours of visible functional areas.
EG would interact with Evergreen,
changing incoming data packets into data objects that UI can more easily digest.
Conversely, it would change objects into packets for delivery to EG.
EG would also deal with session control and cache control.
See the next section for details.

* _Organize software using two types of modularity_,
`plugins' for packaging functional areas,
and `modules' for defining dependencies and downloadable units.
+
Plugins would contain the layout and code to define functional areas.
We may define a functional area using several plugins,
for example, we define the search bar plugin
using a plugin for defining the library selector
and a plugin for defining the sort selector.
In essence, plugins are composable `building blocks'
that designers rearrange, alter, or create to define new UI features.
See the next section for details.
+
We package plugins inside modules.
We may package several plugins in one module,
so that they will be downloaded as one unit.
For example, we define the title details area
by four plugins contained within one module
that is downloaded together.
The main plugin relies on three other plugins
that define each area of the title details screen,
the title details, the holdings details, and the place holds form.

* _Use http://jquery.com[jQuery], the most popular Javascript library,
and http://jashkenas.github.com/coffee-script[Coffeescript], a dialect of Javascript._
+
The first reason to use jQuery
is to help meet the `Target Narrow Bandwidth' design goal, as discussed above.
The second reason is because of its popularity.
Using a popular Javascript library,
especially for the vital operation of manipulating the DOM,
allows for a greater pool of designers
to get involved more quickly with future design work.
+
The decision to use jQuery seems to be countered by the decision to write code in Coffeescript,
a recent project that has yet to gain the popularity of the jQuery project.
Files written in Coffeescript are compiled into Javascript,
and therefore, designers have to learn Coffeescript before they are able to make contributions.
However, Coffeescript can be learnt in one day.
The long-lasting yield that comes from the quick study 
is more succint source code that compiles into more rigorous Javascript coding patterns.
See the section `Coding Patterns' for details.

== Details of the Software Architecture
In this section, we describe the services of the EG and UI layer in more detail.
The architecture is evident from the layout of the project source directory.
----
account/             <4>
eg/                  <2>
lib/                 <5>
opac/                <3>
load_spinner.coffee
login_bar.coffee
login_window.coffee
messages.coffee
mobile_opac.coffee   <1>
plugin.coffee
template.coffee
----
<1> The main source file and common utility files are stored in the top directory.
<2> The EG layer is stored in the `eg' sub-directory.
The remaining sub-directories and files comprise the UI layer.
<3> The plugins defining the catalogue search functions are stored in `opac'.
<4> Those defining the user's account functions are stored in `account'.
<5> External Javascript libraries such as jQuery
and others yet to be discussed are stored in the `lib' sub-directory.

=== EG layer
The raw Evergreen API consists of many OpenSRF service calls,
each requiring the caller to specify request data,
possibly a session ID, and possibly a user ID.
Response data come in all shapes and sizes
and needs to be normalized within another layer of software.
Thus, objectives of the EG layer are as follows.

* _Service name aliases._
Shorten service names from, for example,
+
----
service='open-ils.search', method='open-ils.search.biblio.multiclass.query'
----
+
to a name which has less redundant components.
+
----
'search.biblio.multiclass.query',
----
+
We omit the prefix because it is common,
and we assume a service call will not specify the method of another service.

* _Package request data values into a list_,
the natural data format of the API.
Also, provide sensible default values for service calls
that offer more general services than those needed by UI.

* _Package response data values into sensible data objects._
If response data is a list of anonymous values, convert it into a named object.
If necessary, recurse into nested lists and return nested data objects.
If response data is meant to be a tree of data objects,
for example, the organization unit tree,
flatten the tree of objects.

* _Combine frequently occuring sequences of multiple service calls._
For example, the two-phase login sequence
consisting of `auth.authenticate.init' and `auth.authenticate.complete'
is combined into one service call `auth.session.create'.

* _Persist session IDs and user profiles, which include user ID, for future use._
For services accessing user records and circulation transactions,
all of which require a session ID to succeed,
automatically provide it if there is an active session.
For services requiring a user ID as well,
provide it automatically if one is not specified.

* _Response data caching._
* _Automatic login event._
* _Normalize data typing._
* _Handle AJAX errors_,
for example, network timeouts, bad formulation of requests or responses, and so on.
Errors are published to the UI layer.

=== UI layer
The end result of the services of the EG layer
is to allow the UI layer to do its job with clarity and without distraction.
The main component of the UI layer is plugins.
We design a primitive messaging system to allow plugins to communicate with each other.
Plugins can publish or subscribe to data.
Plugins can be refreshed.
The UI layer is based on the notion of designing a plugins
Behave autonomously.
Interactive behaviours coupled with HTML patterns or templates.
Uses the EG layer to communicate with EG services.


== Coding Patterns
When Coffeescript is used,
the resulting code is more succinct and clearer to understanding than Javascript.
For example, the following one-liner in Coffeescript
defines a function to return the list of property values of a data object.
----
f = (o) -> v for k, v of o
----
The one-liner compiles into more verbose, but rigorously correct Javascript code.
As can be seen, the compiled code is laid out well enough to be readable during a debugging session.
----
var f;
var __hasProp = Object.prototype.hasOwnProperty;
f = function(o) {
  var _a, _b, k, v;
  _a = []; _b = o;
  for (k in _b) {
    if (!__hasProp.call(_b, k)) continue;
    v = _b[k];
    _a.push(v);
  }
  return _a;
};
----

We find four patterns which determine the general look and feel of the mobile opac software.
We present each pattern in Coffeescript.

=== Defining modules
Modules are packages of code that define plugins and other data objects
which can be downloaded dynamically.
Modules are implemented using the
http://thisismedium.com/tech/jmod-bringing-modules-javascript/[jMod library].
A module can depend on other modules,
in which case, those modules are automatically downloaded asynchronously
and in the order defined by the dependency list.
The following fragment of 'Coffeescript' show how a module with three dependencies is defined.
----
module 'opac.a_module', imports(                  <1>
  'eg.eg_api'                                     <2>
  'template'                                      <3>
  'plugin'                                        <4>
), (eg, _) ->                                     <5>
  tpl_content = _.template html_fragment          <6>
  $.fn.a_plugin = plugin_definition               <7>
----
<1> A module is defined by specifying the location of its file
and a list of other modules that need to be imported.
The file location is specified with respect to a predefined root directory;
location `a.b' means file `b' in subdirectory `a'.
<2> Most modules need the services of the EG layer.
Downloaded first because it is listed first.
<3> Modules need the template module to define HTML templates.
Downloaded second.
<4> Modules need the plugin module to define plugins.
Downloaded last.
<5> Imported functions are available within a module's namespace;
for example, we define the namespaces of the EG and template modules
so that their public functions can be accessed.
The plugin module has no public functions other than ones defined as jQuery methods,
therefore, there is no need to define a namespace for the module.
<6> Use the template method defined in the template module;
see below for details on how to define templates.
<7> Define a plugin within the module;
see below for details on how to define plugins.

If a module needs to be downloaded dynamically,
in response to a user event for example,
the 'jMod' library provides a `thunk' function for this purpose.
----
@delegate '.login', 'click', ->                     <1>
  thunk imports('login_window'), show_login_window  <2>
----
<1> Upon a login click, show the login prompt for the user.
<2> Dynamically download the login window module only when needed,
and then show the window after download.

=== Defining plugins
The following code excerpt shows how a typical plugin is defined.
----
$.fn.a_plugin = ->                                <1>
    @plugin('plugin_name')                        <2>
    .append( $('<form>') )                        <3>
    .delegate('form', 'submit', handle_submit)    <4>
    .publish('channel_A', [data])                 <5>
    .subscribe('channel_B', handle_subscription)  <6>
    .refresh(handle_refresh)                      <7>
----
<1> Define the plugin using the jQuery mechanism, whereby each plugin is a jQuery method.
`this' refers to a container, typically a <div> element.
<2> Decorate the plugin with a unique class name that defines instances of this plugin.
<3> Define the content of the plugin container, for example, append a form element.
<4> Bind an event handler to respond to all submit events to the form.
<5> Publish any relevant data values on channel A.
<6> Bind an event handler to respond to subscriptions to data values on channel B.
<7> Bind an event handler to respond to refresh events,
for example, to update the display area.

=== Defining HTML templates
HTML fragments are often defined within a plugin using `micro-templates'.
The following is an example of how a template for a div element is defined and used.
----
tpl_content = _.template '''            <1>
  <div id="<%= id %>">                  <2>
    <span><%= date %></span>
    <span><%= note %></span>
  </div>
'''
show_content = (data) ->                <3>
  @append tpl_content {                 <4>
    id: x.id
    date: x.date
    note: x.note
  } for x in data
----
<1> Define a template function for showing content.
The template function is defined using a constructor function
from the `underscore' Javascript library.
Input is a fragment of HTML defined in the `heredoc' syntax that is available in 'Coffeescript'.
<2> Within the template, variables for data values are defined.
<3> Define a function to use the template function to show values from a given data array.
<4> The input is a data object specifying template variable names and their associated data values.

=== Making AJAX calls
The main purpose of the EG layer is to allow AJAX calls to be easily made.
Here are some examples.
----
eg.openils 'actor.org_tree.retrieve', calculate_org_tree   <1>
eg.openils 'search', request, handle_response              <2>
eg.openils 'actor.user.checked_out', handle_response       <3>
----
<1> Retrieve the organizational tree and bind a handler to the response.
The call requires no parameters other than the service name.
<2> Search the public catalogue and bind a handler to the response.
The call specifies the search details in the request data object.
<3> Retrieve checkout details for the user and bind a handler to the response.
The EG layer provides session ID and user ID for the service call if they are available,
otherwise an event is triggered and the service call is deferred.

If the natural response of a service call is to show the data in a DOM container,
then we convert the container to a jQuery object and apply the `openils' method.
----
$('div.checkout').openils 'checkout details', 'actor.user.checked_out', show_checkout_details
----
As a side effect,
the container acts as an indicator to show the progress of the service call.
During loading, it shows `Loading checkout details';
if there is network failure,
it will show `Failed to load checkout details. Try again';
if successful, the handler is given the container as the context in which to do its work.

If two or more service calls should complete before a unit of work can be done,
we would use the `parallel' method, as follows.
----
$('div.summary_bar').parallel 'search results',  <1>
  ou_tree: eg.openils 'actor.org_tree.retrieve'  <2>
  result: eg.openils 'search', request           <3>
, (x) ->                                         <4>
  calculate_ou_tree x.ou_tree                    <5>
  show_result x.result                           <6>
----
<1> Apply the parallel method to a container that will also indicate progress.
<2> Retrieve the org tree and assign the result to the `ou_tree' object.
<3> Search public catalogue and assign results to the `result' object.
<4> Define a callback to perform work after both service calls are completed.
The callback argument defines the overall object containing both result objects.
<5> Calculate the ou tree based on the returned data.
<6> Show search results.

=== Using a content delivery network
jQuery is a popular library that may already be cached within the mobile browser
because it was used by another recently browsed website.
If so, then it is not necessary to download jQuery again.
In order for this cacheing mechanism to take place,
we use http://code.google.com/apis/libraries/devguide.html[Google's Content Delivery Network].
The relevant script tag would be:
----
<script src='http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js' />
----


== Development Tools and Setup
A set of development tools need to be installed on a designer's workstation
before work can proceed, as follows.
Happily, the tools are open-source software
that can be installed on all platforms, including Windows.

* http://jashkenas.github.com/coffee-script[Coffeescript],
http://nodejs.org/#download[nodejs], and http://npmjs.org[npm].
Coffeescript is itself written in Coffeescript and therefore needs a Javascript engine to run.
'Nodejs' provides that Javascript engine on the server.
Incidentally, 'nodejs' has a package manager
and it should be installed to allow Coffeescript to be easily updated.

* http://closure-compiler.googlecode.com/files/compiler-latest.zip[closure] and Java.
'closure' turns regular Javascript files into minified files for production use.
'closure' is written in Java.

* http://www.methods.co.nz/asciidoc/INSTALL.html[asciidoc] and Python.
High-level documentation, such as this document, is written in 'asciidoc' format.
'asciidoc' is written in Python.

* http://jashkenas.github.com/docco/[docco],
http://pygments.org/download/[pygments], and Python.
Source code files are processed by 'docco' into HTML documentation.
'docco' requires the use of 'pygments' to do syntax highlighting.
'pygments' is written in Python.

* Apache web server. Reverse proxy configuration.

* http://cygwin.com[cygwin].
If the designer's workstation uses Windows, then 'cygwin' needs to be installed on it
to allow 'nodejs' and therefore Coffeescript to run.
There are native installations of Java and Python for Windows.
