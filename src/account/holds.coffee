# holds.coffee
#
# The list_holds plugin lists a user's holds. It listens on the 'userid'
# channel, stores the id, and displays the holds when it's refreshed. The
# account_holds plugin waits for a refresh event and publishes the userid of
# the currently logged in user before triggering the list_holds plugin inside it.

module 'account.holds', imports(
	'eg.eg_api'
	'eg.fieldmapper'
	'template'
	'plugin'
), (eg, fm, _) ->

	tpl_form = '''
	<form>
		<div data-role="fieldcontain">
			<fieldset data-role="controlgroup" />
		</div>
		<div data-role="controlgroup" data-type="horizontal">
			<span class="cancel some"><button type="submit">Cancel selected holds</button></span>
			<span class="cancel all"><button type="submit">Cancel all</button></span>
			<span class="suspend some"><button type="submit">Suspend selected holds</button></span>
			<span class="suspend all"><button type="submit">Suspend all</button></span>
			<span class="resume some"><button type="submit">Activate selected holds</button></span>
			<span class="resume all"><button type="submit">Activate all</button></span>
		</div>
	</form>
	'''
	tpl_item = _.template '''
	<div class="my_hold" id="hold_id_<%= hold_id %>">
		<input type="checkbox" name="hold_id" value="<%= hold_id %>" id="checkbox_<%= hold_id %>" />
		<label for="checkbox_<%= hold_id %>">
			<span class="info_line" />
			<br />
			<span class="status_line" />
		</label>
	</div>
	'''
	tpl_info_line = _.template '''
	<span class="title"> <%= title %> </span>
	<span class="types"> <%= types %> </span>
	<br />
	<span class="author"> <%= author %> </span>
	'''
	tpl_status_line = (o) ->
		a = if o.status is 'Ready for Pickup'
			b = '''
			<span><strong><%= status %></strong> at <%= pickup %></span>
			'''
			c = if o.hold.shelf_time
					'''
					<span>Expires on <strong><%= shelf %></strong></span>
					'''
				else
					''
			'<div>' + b + '</div><div>' + c + '</div>'
		else if o.status is 'In transit'
			b = '''
			<span><%= status %></span>
			'''
			c = '''
			<span>Pick up at <%= pickup %></span>
			'''
			d = if o.hold.shelf_time
					'''
					<span>Expires on <strong><%= shelf %></strong></span>
					'''
				else
					''
			'<div>' + b + '<div></div>' + c + '</div>'
		else
			b = if o.queue_position and o.potential_copies
					'''
					<span>Position <%= posn %> of <%= total %></span>
					'''
				else
					''
			c = if o.potential_copies is 1
					'''
					<span><%= avail %> copy available</span>
					'''
				else if o.potential_copies > 1
					'''
					<span><%= avail %> copies available</span>
					'''
				else
					''
			d = '''
				<span>Pick up at <%= pickup %></span>
				<span>Expires on <%= expire %></span>
				'''
			'<div>' + b + c + '</div><div>' + d + '</div>'
		_.template a

	pad = (x) -> if x < 10 then '0' + x else x
	datestamp = (x) ->
		"#{pad x.getMonth() + 1}/#{pad x.getDate()}/#{x.getFullYear()}"

	$.fn.holds = ->

		$plugin = @plugin('acct_holds').page()

		# List of current holds for logged-in user.
		holds = []

		# Use ajax to cancel a hold given its transaction id.
		cancel = (hold) ->
			eg.openils 'circ.hold.cancel', hold, (status) ->
				if status is 1
					#$().publish 'notice', ['Hold cancelled']
				else
					$().publish 'prompt', ['Hold was not cancelled', status]

		# Use ajax to update a hold given its transaction record.
		update = (hold) ->
			hold_id = hold.id
			eg.openils 'circ.hold.update', hold, (id) ->
				if id is hold_id
					# FIXME: the same hold id is returned.
					# We could avoid refreshing holds list, just update individual status lines.
					return id
				else
					# FIXME: is there a server error message generated by eg_api layer?
					$().publish 'prompt', ['Hold was not updated', id]
					return

		# Refresh summary line and details list.
		refresh = ->
			$plugin.ajaxStop ->
				$(@).unbind('ajaxStop').refresh().publish 'holds_summary'
				return false


		@refresh ->
			@html(tpl_form).page('destroy').page()
			$list = $('fieldset', @)

			# Hide action buttons until they are needed.
			$cancel_some = $('.cancel.some', @).hide()
			$cancel_all = $('.cancel.all"', @).hide()
			$suspend_some = $('.suspend.some', @).hide()
			$suspend_all = $('.suspend.all', @).hide()
			$resume_some = $('.resume.some', @).hide()
			$resume_all = $('.resume.all', @).hide()
			# Show action buttons as necessary.
			show_buttons = (frozen) ->
				if $cancel_all.is ':visible'
					$cancel_some.show()
				else
					$cancel_all.show()
				if frozen
					if $resume_all.is ':visible'
						$resume_some.show()
					else
						$resume_all.show()
				else
					if $suspend_all.is ':visible'
						$suspend_some.show()
					else
						$suspend_all.show()
				return

			###
			eg.openils 'circ.hold.details.retrieve.authoritative', 1, (o) =>
				if o.ilsevent? and o.ilsevent is '5000'

					# Same sequence as full OPAC for open-ils v1.6.
					# However, suffers from database replication error.
					$list.parallel 'holds list',
						ahrs: eg.openils 'circ.holds.retrieve'
						ouTree: eg.openils 'actor.org_tree.retrieve'
					, (x) =>
						for hold in x.ahrs
							$list.append $item = $(tpl_item hold_id: hold.id)
							do (hold, $item) ->
								$item.parallel 'holds details',
									mvr: eg.openils 'search.biblio.record.mods_slim.retrieve', hold.target
									hqs: eg.openils 'circ.hold.queue_stats.retrieve', hold.id
								, (o) ->
									o.hold = hold
									o.status = o.hqs.status
									o.queue_position = o.hqs.queue_position
									o.total_holds = o.hqs.total_holds
									o.potential_copies = o.hqs.potential_copies

									holds.push o.hold
									$('.info_line', $item).append tpl_info_line
										title: o.mvr.title if o.mvr.title
										author: "#{o.mvr.author}" if o.mvr.author
										types: "#{(o.mvr.types_of_resource).join ', '}" if o.mvr.types_of_resource
									$('.status_line', $item).append (tpl_status_line o)
										status: o.status if o.status
										posn:	o.queue_position
										total:	o.total_holds
										avail:	o.potential_copies
										pickup: "#{x.ouTree[o.hold.pickup_lib].name}" if o.hold.pickup_lib
										expire: if o.hold.expire_time then "#{datestamp o.hold.expire_time}" else ''
										shelf: if o.hold.shelf_time then "#{datestamp o.hold.shelf_time}" else ''
									$('input, .info_line, .status_line', $item).addClass if o.hold.frozen then 'inactive' else 'active'
									show_buttons o.hold.frozen
									$item.page()
				else
			###

			# A sequence for open-ils v2.0
			# which does not show the database replication error.
			$list.parallel 'holds list',
				ids: eg.openils 'circ.holds.id_list.retrieve.authoritative'
				ouTree: eg.openils 'actor.org_tree.retrieve'
			, (x) =>
				for id in x.ids
					$list.append $item = $(tpl_item hold_id: id)
					do ($item) ->
						$item.openils "holds details ##{id}", 'circ.hold.details.retrieve.authoritative', id, (o) ->

							# Accumulate holds object in a list.
							# Useful for updating as the updated object needs to be returned to the server.
							holds.push o.hold

							$('.info_line', $item).append tpl_info_line
								title: o.mvr.title if o.mvr.title
								author: "#{o.mvr.author}" if o.mvr.author
								types: "#{(o.mvr.types_of_resource).join ', '}" if o.mvr.types_of_resource
							$('.status_line', $item).append (tpl_status_line o)
								status: o.status if o.status
								posn:	o.queue_position
								total:	o.total_holds
								avail:	o.potential_copies
								pickup: "#{x.ouTree[o.hold.pickup_lib].name}" if o.hold.pickup_lib
								expire: if o.hold.expire_time then "#{datestamp o.hold.expire_time}" else ''
								shelf: if o.hold.shelf_time then "#{datestamp o.hold.shelf_time}" else ''
							$('input, .info_line, .status_line', $item).addClass if o.hold.frozen then 'inactive' else 'active'
							show_buttons o.hold.frozen
							$item.page()
			return false

		@delegate '.cancel.some', 'click', ->
			xids = $(@).closest('form').serializeArray()
			if xids.length
				cancel xid.value for xid in xids
				refresh()
			else
				$(@).publish 'notice', ['Nothing was done because no holds were selected.']
			return false

		@delegate '.cancel.all', 'click', ->
			$xs = $(@).closest('form').find('input:checkbox')
			if $xs.length
				$xs.each -> cancel $(@).val()
				refresh()
			else
				$(@).publish 'notice', ['Nothing was done because no holds can be cancelled.']
			return false

		@delegate '.suspend.some', 'click', update_some = ->
			suspend = $(@).hasClass 'suspend'
			xids = $(@).closest('form').serializeArray()
			if xids.length
				for xid in xids
					for hold in holds when hold.id is parseInt xid.value
						hold.frozen = suspend
						update hold
						break
				refresh()
			else
				$(@).publish 'notice', ['Nothing was done because no holds were selected.']
			return false

		@delegate '.suspend.all', 'click', update_all = ->
			suspend = $(@).hasClass 'suspend'
			$xs = $(@).closest('form')
				.find(".my_hold #{if suspend then '.active' else '.inactive'}")
				.closest 'input:checkbox'
			if $xs.length
				$xs.each ->
					for hold in holds when hold.id is parseInt $(@).val()
						hold.frozen = suspend
						update hold
						break
				refresh()
			else
				$(@).publish 'notice', if suspend then ['Nothing was done because no active holds were found to suspend.'] else ['Nothing was done because no suspended holds were found to activate.']
			return false

		@delegate '.resume.some', 'click', update_some
		@delegate '.resume.all', 'click', update_all
