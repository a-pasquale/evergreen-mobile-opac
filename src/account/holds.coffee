# holds.coffee
#
# The list_holds plugin lists a user's holds. It listens on the 'userid'
# channel, stores the id, and displays the holds when it's refreshed. The
# account_holds plugin waits for a refresh event and publishes the userid of
# the currently logged in user before triggering the list_holds plugin inside it.

module 'account.account_holds', imports('eg.eg_api', 'plugin'), (eg) ->
	$.fn.account_holds = ->
		@append $('<div>').holds()
		@refresh ->
			@publish 'userid', [eg.auth.session.user.id] if eg.auth.session?.user?
			return false


module 'account.holds', imports(
	'eg.eg_api'
	'eg.fieldmapper'
	'template'
	'plugin'
), (eg, fm, _) ->

	tpl_hold_form = '''
	<form>
		<input type="submit" class="cancel" name="some" value="Cancel selected holds" />
		<input type="submit" class="cancel" name="all" value="Cancel all" />
		<input type="submit" class="suspend" name="some" value="Suspend selected holds" />
		<input type="submit" class="suspend" name="all" value="Suspend all" />
		<input type="submit" class="resume" name="some" value="Resume selected holds" />
		<input type="submit" class="resume" name="all" value="Resume all" />
	</form>
	'''
	tpl_hold_item = _.template '''
	<div class="my_hold <%= hold_activity %>" id="hold_id_<%= hold_id %>">
		<input type="checkbox" name="hold_id" value="<%= hold_id %>" />
		<span class="info_line">
			<span class="title" />
			<span class="author" />
			<span class="types" />
		</span>
		<div class="status_line">
			<span class="hold_status" /> <%= hold_pickup %> <%= hold_expire %>
		</div>
	</div>
	'''
	show_info_line = (mvr) ->
		$('.title', @).text mvr.title if mvr.title
		$('.author', @).text "/ #{mvr.author}" if mvr.author
		$('.types', @).text "/ #{(mvr.types_of_resource).join ', '}" if mvr.types_of_resource


	$.fn.holds = ->

		$plugin = @

		# List of current holds for logged-in user.
		holds = []

		# Use ajax to cancel a hold given its transaction id.
		cancel = (hold) ->
			eg.openils 'circ.hold.cancel', hold, (status) ->
				if status is 1
					#$().publish 'notice', ['Hold cancelled']
				else
					$().publish 'prompt', ['Hold was not cancelled', status]

		# Use ajax to update a hold given its transaction record.
		update = (hold) ->
			hold_id = hold.id
			eg.openils 'circ.hold.update', hold, (id) ->
				if id is hold_id
					# FIXME: the same hold id is returned.
					# We could avoid refreshing holds list, just update individual status lines.
					return id
				else
					# FIXME: is there a server error message generated by eg_api layer?
					$().publish 'prompt', ['Hold was not updated', id]
					return

		# Refresh summary line and details list.
		refresh = ->
			$plugin.ajaxStop ->
				$(@).unbind('ajaxStop').refresh().publish 'holds_summary'
				return false


		@plugin('acct_holds')

		.subscribe 'userid', (id) ->
			@refresh() if @is ':visible'
			return false

		.subscribe 'logout_event', ->
			@empty()
			return false

		.refresh ->
			@empty().append $list = $ tpl_hold_form
			# Hide action buttons until they are needed.
			$cancel_some = $('.cancel[name="some"]', @).hide()
			$cancel_all = $('.cancel[name="all"]', @).hide()
			$suspend_some = $('.suspend[name="some"]', @).hide()
			$suspend_all = $('.suspend[name="all"]', @).hide()
			$resume_some = $('.resume[name="some"]', @).hide()
			$resume_all = $('.resume[name="all"]', @).hide()

			$list.parallel 'holds details',
				holds:  eg.openils 'circ.holds.retrieve'
				ouTree: eg.openils 'actor.org_tree.retrieve'
			, (x) =>

				holds = x.holds # FIXME: need to do this to pass value to click handlers.
				@publish 'holds', [x.holds]
				for hold in x.holds
					$list.prepend $hold_item = tpl_hold_item {
						hold_id:       hold.id
						hold_activity: if hold.frozen then 'inactive' else 'active'
						hold_pickup:   if hold.pickup_lib then "at #{x.ouTree[hold.pickup_lib].name}" else ''
						hold_expire:   if hold.expire_time then "until #{hold.expire_time.slice 0, 10}" else ''
					}

					# Show action buttons as necessary.
					if $cancel_all.is ':visible'
						$cancel_some.show()
					else
						$cancel_all.show()
					if hold.frozen
						if $resume_all.is ':visible'
							$resume_some.show()
						else
							$resume_all.show()
					else
						if $suspend_all.is ':visible'
							$suspend_some.show()
						else
							$suspend_all.show()

					( (hold) ->
						$x = $("#hold_id_#{hold.id}")
						$('.hold_status', $x).openils 'hold status', 'circ.hold.status.retrieve', hold.id, (status) ->
							@text status[1]

						$il = $('.info_line', $x)
						switch hold.hold_type
							when 'M'
								$il.openils 'title_info', "search.biblio.metarecord.mods_slim.retrieve", hold.target, show_info_line
							when 'T'
								$il.openils 'title info', "search.biblio.record.mods_slim.retrieve", hold.target, show_info_line
							when 'V'
								$il.openils 'callnumber info', "search.asset.call_number.retrieve", hold.target, (cn) ->
									@openils 'title info', "search.biblio.record.mods_slim.retrieve", cn.record, show_info_line
							when 'C'
								$il.openils 'copy info', "search.asset.copy.retrieve", hold.target, (copy) ->
									@openils 'callnumber info', "search.asset.call_number.retrieve", copy.call_number, (cn) ->
										@openils 'title info', "search.biblio.record.mods_slim.retrieve", cn.record, show_info_line
					) hold

			.error (e) ->
				#console.error e
				alert JSON.stringify e, null, '  '

			return false

		@delegate '.cancel[name=some]', 'click', ->
			xids = $(@).parent().serializeArray()
			if xids.length
				cancel xid.value for xid in xids
				refresh()
			else
				$(@).publish 'notice', ['Nothing was done because no holds were selected.']
			return false

		@delegate '.cancel[name=all]', 'click', ->
			$xs = $(@).parent().find('input:checkbox')
			if $xs.length
				$xs.each -> cancel $(@).val()
				refresh()
			else
				$(@).publish 'notice', ['Nothing was done because no holds were selected.']
			return false

		@delegate '.suspend[name=some]', 'click', update_some = ->
			suspend = $(@).hasClass 'suspend'
			xids = $(@).parent().serializeArray()
			if xids.length
				for xid in xids
					for hold in holds when hold.id is parseInt xid.value
						hold.frozen = suspend
						update hold
						break
				refresh()
			else
				$(@).publish 'notice', ['Nothing was done because no holds were selected.']
			return false

		@delegate '.suspend[name=all]', 'click', update_all = ->
			suspend = $(@).hasClass 'suspend' # suspend or resume?
			$form = $(@).parent()
			if suspend
				$xs = $('.my_hold.active', $form).find 'input:checkbox'
			else
				$xs = $('.my_hold.inactive', $form).find 'input:checkbox'
			if $xs.length
				$xs.each ->
					for hold in holds when hold.id is parseInt $(@).val()
						hold.frozen = suspend
						update hold
						break
				refresh()
			else
				$(@).publish 'notice', if suspend then ['Nothing was done because no active holds were found to suspend.'] else ['Nothing was done because no suspended holds were found to resume.']
			return false

		@delegate '.resume[name=some]', 'click', update_some
		@delegate '.resume[name=all]', 'click', update_all
