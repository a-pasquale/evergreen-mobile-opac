// Generated by CoffeeScript 1.3.1

define(['eg/eg_api', 'eg/services', 'eg/date'], function(eg, services, date) {
  var cache, cacheTO, clean_cache, key, last_cleaned, queue;
  cacheTO = 60;
  cache = {};
  queue = {};
  last_cleaned = date.now();
  clean_cache = function() {
    var current, k, o, _results;
    current = date.now();
    if ((current - last_cleaned) < (20 * 1000)) {
      return;
    }
    last_cleaned = current;
    _results = [];
    for (k in cache) {
      o = cache[k];
      if ((o.timestamp + o.expiry) < current) {
        _results.push(delete cache[k]);
      }
    }
    return _results;
  };
  key = function(method, request) {
    var stringify;
    stringify = function(request) {
      var a, name, names, _i, _len, _ref;
      names = [];
      a = [];
      switch (typeof request) {
        case 'string':
        case 'number':
        case 'boolean':
          a.push(String(request));
          break;
        case 'function':
        case 'undefined':
          a.push('undefined');
          break;
        default:
          if (request === null) {
            a.push('null');
          } else {
            for (name in request) {
              names.push(name);
            }
            _ref = names.sort();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              name = _ref[_i];
              a.push(name, stringify(request[name]));
            }
          }
      }
      return a.join('|');
    };
    return method + '|' + stringify(request);
  };
  return function(method, request, d) {
    var entry, expiry, k, lookup, req_deferred;
    lookup = services[method];
    k = key(method, request);
    entry = cache[k];
    expiry = lookup.c;
    expiry *= cacheTO * 1000;
    if (((entry != null ? entry.timestamp : void 0) + expiry) > date.now()) {
      next(function() {
        return d.call(entry.data);
      });
      return d;
    }
    if (queue[k] === void 0) {
      queue[k] = [];
    }
    queue[k].push(d);
    if (entry === false) {
      return d;
    }
    cache[k] = false;
    req_deferred = new Deferred();
    req_deferred.next(function(result) {
      var _ref;
      entry = {
        timestamp: date.now(),
        data: result
      };
      cache[k] = entry;
      while (((_ref = queue[k]) != null ? _ref.length : void 0) > 0) {
        queue[k].pop().call(entry.data);
      }
    }).error(function(e) {
      var textStatus, _ref;
      textStatus = e[0];
      while (((_ref = queue[k]) != null ? _ref.length : void 0) > 0) {
        queue[k].pop().fail(textStatus);
      }
      return delete cache[k];
    });
    (lookup.action || eg.default_action)(method, request, req_deferred);
    clean_cache();
    return d;
  };
});
